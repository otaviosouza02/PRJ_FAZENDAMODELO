# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# PRJ_Modelo_Dados: Inventário da Fazenda Modelo  ~~~~~~~~~~~~~~~~~~~~~
#
# Autor: Luiz Carlos Estraviz Rodriguez
#        Otávio Magalhães Silva Souza
#        Departamento de Ciências Florestais
#        ESALQ/USP - 22/Set/2024
#
#   - download dos dados mantidos em um repositório github público
#      - shape files dos talhões e das parcelas de inventário
#   - sugestão de pasta para armazenamento local:
#        C:/LiDAR/PRJ_Modelo/DADOS
#
# Linguagem de programação:
#       R (v 4.3)
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
rm(list=ls(all=TRUE))                                   # Limpa memória
gc()
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 1. Leitura e organização de dados
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----
if(!require(tidyverse))  # Para melhor manipulação de dados e funções
install.packages("tidyverse")
library(tidyverse)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Download do shape da Fazenda Modelo (2 layers: talhoes e parcelas)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
gitOnde <- "https://github.com/FlorestaR/dados/blob/main/5_LIDARF/Modelo/SHAPES"
gitNome <- "fazmodelo.zip"
gitArqv <- file.path(gitOnde, gitNome) %>% paste0("?raw=true")
tmpd <- tempdir(check = TRUE)                    # diretório temporário
zipf <- file.path(tmpd, "shapes.zip")              # arquivo temporário
options(timeout=1000) # Reset timeout oferecendo mais tempo de download
if(!file.exists(zipf))  # garante download de dados binários (wb)
download.file(gitArqv, mode="wb", destfile = zipf)
unzip(zipf, exdir = tmpd)     # shape é unziped no diretório temporário
unlink(zipf)                                  # deleta o arquivo zipado
if(!require(sf))                           # Para manipulação de shapes
install.packages("sf")
library(sf)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Lê atributos dos talhoes
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
shpArq <- paste0(tmpd, "/Modelo_talhoes.shp")       # shape com talhões
talhoesComGeo <- read_sf(shpArq)                    # completo com geom
talhoesSemGeo <- tibble(sf::st_drop_geometry(talhoesComGeo))  # s/ geom
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Lê atributos das parcelas
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
shpArq <- paste0(tmpd, "/Modelo_parcelas.shp")     # shape com parcelas
parcelasComGeo <- read_sf(shpArq)                   # completo com geom
parcelasSemGeo <- tibble(sf::st_drop_geometry(parcelasComGeo)) # s/geom
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Lê atributos do grid
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
shpArq <- paste0(tmpd, "/Modelo_grid.shp")           # shape com o grid
gridComGeo <- read_sf(shpArq)                       # completo com geom
gridSemGeo <- tibble(sf::st_drop_geometry(gridComGeo))        # s/ geom
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Cria coluna IDINV na tabela "talhões", extraída da tabela "parcelas"
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
talhoes <-
parcelasSemGeo %>%
group_by(SUBTALHAO) %>%
summarise(IDINV = unique(IDINV)) %>%
left_join(talhoesSemGeo) %>%
select("SUBTALHAO", "IDINV", "AREA") %>%
arrange(SUBTALHAO) %>% as.data.frame
talhoesComGeo <- inner_join(talhoesComGeo, talhoes, by="SUBTALHAO") %>%
select("OBJECTID", "SUBTALHAO", "IDINV", "geometry")
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Reorganiza colunas da tabela "parcelas"
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
parcelas <-
parcelasSemGeo %>%
select(SUBTALHAO, CHAVE2, DATAREALIZ, IDINV, AREAPARCEL, MHDOM, VTCC) %>%
arrange(SUBTALHAO) %>% as.data.frame
n <- count(parcelas)
FASE <- rep(1:1, n)
parcelas <- cbind(FASE, parcelas)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Reorganiza colunas da tabela "parcelas"
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
grid <-
gridSemGeo %>%
select(gridcell, rowcell, colcell, areacell, talhao, fase, parcela,
medicao, anoinv, idade, MHDOM, VTCC) %>%
arrange(gridcell) %>% as.data.frame
# Cria diretórios e pastas para onde os tiles LiDAR serão copiados
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prjNome <- 'PRJ_Modelo'
dirNome <- paste0('C:/LiDAR/', prjNome)
dir.create(dirNome, showWarnings = F)
# Salva e imprime dados reorganizados
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dirNome <- paste0(dirNome, '/DADOS/')
dir.create(dirNome, showWarnings = F)
# Leitura da mais atual versão rio para facilmente ler e salvar Excel
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if (!require("remotes")){install.packages("remotes")}
if (!require(rio))      {remotes::install_github("gesistsa/rio")}
library(rio)
# Salva dados em planilha Excel
arqNome <- paste0(dirNome, prjNome, '.xlsx')
export(list(talhoes = talhoes,
parcelas  = parcelas,
grid = grid),
file = arqNome)
# Mostra tabelas no Viewer
# Use o "Export" do Viewer para salvar em diferentes formatos
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if(!require(kableExtra))
install.packages("kableExtra")
library(kableExtra)
# Mostra talhões
AreaTotal <- talhoes$AREA %>% sum
NotaDeRodape <- paste0(": ", AreaTotal)
talhoes %>%
kbl(caption = "Talhões da Fazenda Modelo", align = "r") %>%
kable_classic(full_width = F) %>%
footnote(general = NotaDeRodape,
general_title = "Área total",
footnote_as_chunk = T)
# Mostra parcelas
parcelas %>%
kbl(caption = "Parcelas da Fazenda Modelo", align = "r") %>%
kable_classic(full_width = F)
# Cria diretório para salvar mapas
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dirNome <- paste0('C:/LiDAR/', prjNome)
dir.create(dirNome, showWarnings = F)
dirNome <- paste0(dirNome, '/MAPAS/')
dir.create(dirNome, showWarnings = F)
# Cria mapa dos talhões com localização das parcelas (EPSG: 31983)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
arqNome <- paste0(dirNome, prjNome, '.png')
png(arqNome, 30, 20, 'cm', res = 200)                # abre "impressão"
ggplot() +        #         plot dos talhões e parcelas (cor por idade)
geom_sf(data = talhoesComGeo, colour = "black", fill="white") +
geom_sf(data = parcelasComGeo, aes(fill = factor(IDINV))) +
scale_fill_discrete(name = "Idade") +
guides(fill = guide_legend(reverse=F)) +
coord_sf(datum=st_crs(31983)) +        # Especifica sistema de coord.
scale_y_continuous(breaks = seq(from=7356500,to=7359000, by=200)) +
scale_x_continuous(breaks = seq(from=206200, to=207600,  by=200))
dev.off()                                # fecha "impressão" do aquivo
# ----
if (!require("remotes")){install.packages("remotes")}
if (!require(rio))      {remotes::install_github("gesistsa/rio")}
library(rio)
# Leitura da versão mais atual do pacote Tidyverse para
# melhor agilidade e organização do script
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if(!require(tidyverse))  # Para melhor manipulação de dados e funções
install.packages("tidyverse")
library(tidyverse)
# Leitura da versão mais atual do pacote Tidyverse para
# melhor agilidade e organização do script
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if(!require(kableExtra))  # Para melhor manipulação de dados e funções
install.packages("kableExtra")
library(kableExtra)
# Define local e nome da planilha para leitura dos dados
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prjNome  <- 'PRJ_Modelo'
dirNome  <- paste0('C:/LiDAR/', prjNome, '/DADOS/')
arqNome  <- paste0(dirNome, prjNome, '.xlsx')
talhoes  <- import(arqNome, which = "talhoes")
parcelas <- import(arqNome, which = "parcelas")
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Lê pacote forestinventory
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if(!require(forestinventory))  # Para melhor manipulação de dados e funções
install.packages("forestinventory")
library(forestinventory)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Amostragem simples em fase única - parâmetros do pacote
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Função:
# onephase(
#         formula  = Y ~ 1, Y é a variável medida no campo,
#         data     = dataframe ou vetor com a variável Y,
#         phase_id = list (
#                         phase.col   = nome coluna id da fase,
#                         terrgrid.id = valor numérico do id da fase),
#         area     = list(
#                        sa.col = nome coluna de estratificação,
#                        areas  = vetor c("", "", "") de estratos),
#         cluster  = nome da coluna, se houver cluster sampling)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Amostragem Casual Simples (ACS)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----
AreaTotal <- talhoes$AREA %>% sum             # Área total inventariada
# ACS <- onephase(formula  = MHDOM ~ 1,
ACS <- onephase(formula  = VTCC ~ 1,
data     = parcelas,
phase_id = list(phase.col = "FASE", terrgrid.id = 1))
summary(ACS)
confint(ACS)
parcelas$VTCC
# Número Total de Unidades Amostrais (N) na população ~~~~~~~~~~~~~~~~~
erro         <- 0.05                                    # Erro desejado
tamMedioParc <- mean(parcelas$AREAPARCEL) / 10000               # em ha
N            <- round(AreaTotal / tamMedioParc , 0)
# Função para cálculo da intensidade amostral desejável da ACS
#                           para garantir um certo erro mínimo
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tamanhoIdealACS = function(x, N, erro, alpha = 0.05){
media = ACS$estimation$estimate
var   = ACS$estimation$variance
n     = ACS$estimation$n2
t     = qt(1 - alpha/2, n - 1)
B     = erro * media
ndsej = round((N * var * t^2) / (N * (erro * media)^2 + var * t^2), 0)
lista = cbind(media, B, ndsej) %>% as.data.frame
colnames(lista) = c('media', 'bound', 'ndsej')
return(lista)
}
nACS <- tamanhoIdealACS(ACS, N, erro)
#n = (N * (Z**2) * (sigma**2)) / ((N - 1) * (E**2) + (Z**2) * (sigma**2))
# Tabela com resultados do inventário (estimação + inferência) por ACS
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
IAS <- paste0(" usada: 1 parc/",
round( AreaTotal / ACS$estimation$n2, 0), " ha.")
IAI <- paste0("\n Necessárias p/ erro de ", erro*100, "%: 1 parc/",
round(AreaTotal / nACS$ndsej, 0), " ha.")
NotaDeRodape <- paste0(IAS, IAI)
quadroACS <- as.data.frame(
tibble(LimInf95   = confint(ACS)$ci$ci_lower_op,
Estimativa = ACS$estimation$estimate,
LimSup95   = confint(ACS)$ci$ci_upper_op,
Variância  = ACS$estimation$variance,
n          = ACS$estimation$n2))
quadroACS %>%
kbl(caption = paste0("Amostragem Casual Simples em ~",
round(AreaTotal, 0), " ha."), align = "r") %>%
kable_classic(full_width = F) %>%
footnote(general       = NotaDeRodape,
general_title = "Intensidade amostral",
footnote_as_chunk = T)
# ----
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Amostragem Casual Estratificada (ACE)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----
AreaTotal <- talhoes$AREA %>% sum             # Área total inventariada
# ACE <- onephase(formula  = MHDOM ~ 1,
ACE <- onephase(formula  = VTCC ~ 1,
data     = parcelas,
phase_id = list(phase.col = "FASE", terrgrid.id = 1),
area     = list(sa.col = "IDINV", areas = c(3.7, 5.2)))
summary(ACE)
confint(ACE)
head(parcelas)
# Número Total de Unidades Amostrais (N) por estrato na população ~~~~~
erro         <- 0.1                                    # Erro desejado
tamMedioParc <- mean(parcelas$AREAPARCEL) / 10000               # em ha
N            <- round(AreaTotal / tamMedioParc, 0)
Nh           <- round(tapply(talhoes$AREA, talhoes$IDINV, FUN=sum) /
tamMedioParc, 0)
# Função para cálculo da intensidade amostral desejável da ACE
# para garantir um certo erro mínimo.
#                               Shiver&Borders (1996, pág 129 eq. 5.10)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tamanhoIdealACE = function(x, N, Nh, erro){
media = sum( Nh * x$estimation$estimate ) / N
var   = x$estimation$variance
dh    = sqrt(var)
wh    = (Nh*dh) / sum(Nh*dh)    # desconsiderada diferença nos custos
B     = erro * media
ndsej = round(sum( (Nh^2 * var) / wh ) /
( (N^2  * B^2) / 4 + sum(Nh * var) ), 0)
lista = cbind(media, B, ndsej) %>% as.data.frame
colnames(lista) = c('media', 'bound', 'ndsej')
return(lista)
}
nACE <- tamanhoIdealACE(ACE, N, Nh, erro)
# Tabela com resultados do inventário (estimação + inferência) por ACE
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
IAS <- paste0(" usada: 1 parc/",
round( AreaTotal / sum(ACE$estimation$n2), 0), " ha.")
IAI <- paste0("\n Necessárias p/ erro de ", erro*100, "%: 1 parc/",
round(AreaTotal / nACE$ndsej, 0), " ha.")
NotaDeRodape <- paste0(IAS, IAI)
quadroACE <- as.data.frame(
tibble(
Estrato    = ACE$estimation$area,
LimInf95   = confint(ACE)$ci$ci_lower_op,
Estimativa = ACE$estimation$estimate,
LimSup95   = confint(ACE)$ci$ci_upper_op,
Variância  = ACE$estimation$variance,
n          = ACE$estimation$n2))
quadroACE %>%
kbl(caption = paste0("Amostragem Casual Estratificada em ~",
round(AreaTotal, 0), " ha."), align = "r") %>%
kable_classic(full_width = F) %>%
footnote(general       = NotaDeRodape,
general_title = "Intensidade amostral",
footnote_as_chunk = T)
# ----
if(!require(tidyverse))
install.packages(tidyverse)
library(tidyverse)
# Leitura da versão mais atual do pacote rio
#           para importação de planilhas Excel
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if (!require("remotes")){install.packages("remotes")}
if (!require(rio))      {remotes::install_github("gesistsa/rio")}
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Lê pacote forestinventory
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if(!require(forestinventory))  # Para melhor manipulação de dados e funções
install.packages("forestinventory")
library(forestinventory)
# Define local e nome da planilha para leitura dos dados
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prjNome  <- "PRJ_Modelo"
dirNome  <- paste0('C:/LiDAR/', prjNome, '/DADOS/')
arqNome  <- paste0(dirNome, prjNome, '_metrics.csv')
grid     <- import(arqNome)
# Define local e nome da planilha para leitura dos dados
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prjNome  <- "PRJ_Modelo"
dirNome  <- paste0('C:/LiDAR/', prjNome, '/DADOS/')
arqNome  <- paste0(dirNome, prjNome, '_metrics.csv')
grid     <- import(arqNome)
prjNome
# Define local e nome da planilha para leitura dos dados
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prjNome  <- "PRJ_Modelo"
dirNome  <- paste0('C:/LiDAR/', prjNome, '/DADOS/')
arqNome  <- paste0(dirNome, prjNome, '_metrics.xlsx')
grid     <- import(arqNome)
head(grid)
grid     <- import(arqNome)
arqNome
datDir
datDir <- str_c('C:/LiDAR/', prjNome)    # Define raiz da pasta de dados
metricas_lidarEXC <- str_c(datDir, "/DADOS/", prjNome, "_metrics.xlsx")
metricas_lidarEXC
