qt(1 - 0.05/2, 5-1)
N_max_est
var(X$VTCC[X$Inventario == 2 & X$IDINV == idadesEstratos[1]])
n  = 1377.49*1604.58*2.776445^2 / (1377.49 * 21.494^2 + 2.776445^2 * 1604.58) # Calcula o tamanho ideal de amostra baseando-se na variância de y, no tamanho máx. da pop (N), no limite do erro B e na confiança desejada (95%)
n
N_max
n  = 3446*1604.58*2.776445^2 / (3446 * 21.494^2 + 2.776445^2 * 1604.58) # Calcula o tamanho ideal de amostra baseando-se na variância de y, no tamanho máx. da pop (N), no limite do erro B e na confiança desejada (95%)
n
areaTotal
tamanhoIdealACS
tamanhoIdealACE
tamanhoIdealACE[i] = c(round(areaTotal/(tamanhoIdealACE_fun(X$VTCC[X$Inventario == 2 & X$IDINV == idadesEstratos[1]], N_max_est)), 2))
### Intensidade Amostral: ACE
tamanhoIdealACE = c()
foreach (i = 0:length(unique(X$IDINV))) %do% {
tamanhoIdealACE[i] = c(round(areaTotal/(tamanhoIdealACE_fun(X$VTCC[X$Inventario == 2 & X$IDINV == idadesEstratos[1]], N_max_est)), 2))
}
tamanhoIdealACE
### Intensidade Amostral: ACE
tamanhoIdealACE = c()
tamanhoIdealACE_fun = function(y, N, errDesired=erro/100, alpha=.05){ # Y vai receber o data.frame com a VTCC de cada parcela de campo e N vai receber o número máximo de parcelas de campo
B  =  errDesired * mean(y) # B representa o erro absoluto; é a média das VTCC * 0,1 -> é uma constante que representa o valor do erro de 10% em m³ por ha, se passar do valor de B, então o erro é maior do que 10%
qt = qt(1 - alpha/2, length(y)-1) # quantil 97,5% - 95% de confiança para o grau de liberdade delimitado (13 parcelas de campo - 1 = 12)
n  = N*var(y)*qt^2 / (N * B^2 + qt^2 * N) # Calcula o tamanho ideal de amostra baseando-se na variância de y, no tamanho máx. da pop (N), no limite do erro B e na confiança desejada (95%)
return(n)
}
foreach (i = 0:length(unique(X$IDINV))) %do% {
tamanhoIdealACE[i] = c(round(areaTotal/(tamanhoIdealACE_fun(X$VTCC[X$Inventario == 2 & X$IDINV == idadesEstratos[i]], N_max_est)), 2))
}
tamanhoIdealACE
tamanhoIdealACE[1] = tamanhoIdealACE[1]*(talhoes$AREA/talhoes$AREA[talhoes$IDINV == idadesEstratos[1]])
tamanhoIdealACE
tamanhoIdealACE[1] = tamanhoIdealACE[1]*((sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[1]]))/(areaTotal))
tamanhoIdealACE
sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[1]]))/(areaTotal)
(sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[1]]))/(areaTotal)
}
(sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[1]]))/(areaTotal)
tamanhoIdealACE[2] = tamanhoIdealACE[2]*(sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[2]]))/(areaTotal)
tamanhoIdealACE
### Intensidade Amostral: ACE
tamanhoIdealACE = c()
foreach (i = 0:length(unique(X$IDINV))) %do% {
tamanhoIdealACE[i] = c(round(areaTotal/(tamanhoIdealACE_fun(X$VTCC[X$Inventario == 2 & X$IDINV == idadesEstratos[i]], N_max_est)), 2))
tamanhoIdealACE[i] = tamanhoIdealACE[i]*(sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]]))/(areaTotal)
}
tamanhoIdealACE
IA = sum(tamanhoIdealACE)
IA
### Intensidade Amostral: ACE
tamanhoIdealACE_aux = c()
foreach (i = 0:length(unique(X$IDINV))) %do% {
tamanhoIdealACE_aux[i] = c(round(areaTotal/(tamanhoIdealACE_fun(X$VTCC[X$Inventario == 2 & X$IDINV == idadesEstratos[i]], N_max_est)), 2))
tamanhoIdealACE_aux[i] = tamanhoIdealACE_aux[i]*(sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]]))/(areaTotal)
}
tamanhoIdealACE = sum(tamanhoIdealACE_aux)
tamanhoIdealACE
tamanhoIdealACS
data <- data.frame(
Resultados = c("Estimativa VTCC", "Variância", "Desvio Padrão", "Intervalo de confiança (95%)", "Erro (%)", "Int. Amostral para erro de " + as.character(erro) + "%"),
ACS = c(op_ACS$estimation$estimate, op_ACS$estimation$variance, sqrt(op_ACS$estimation$variance), ciop, erroPercentualACS),
ACE = c(VTCCponderadaACE_final, VarponderadaACE_final, erroPadrao_ponderadoACE, intervaloConfiancaACE, erroPercentualACE),
AD = c(reg2p_nex$estimation$estimate, reg2p_nex$estimation$g_variance, sqrt(reg2p_nex$estimation$g_variance), cir2p, erroPercentualDA),
ADE = c(VTCCponderadaDAE_final, VarponderadaDAE_final, erroPadrao_ponderadoDAE, intervaloConfiancaDAE, erroPercentualDAE)
)
IA = str_c("Int. Amostral para erro de ", as.character(erro), "%")
IA
data <- data.frame(
Resultados = c("Estimativa VTCC", "Variância", "Desvio Padrão", "Intervalo de confiança (95%)", "Erro (%)", IA),
ACS = c(op_ACS$estimation$estimate, op_ACS$estimation$variance, sqrt(op_ACS$estimation$variance), ciop, erroPercentualACS),
ACE = c(VTCCponderadaACE_final, VarponderadaACE_final, erroPadrao_ponderadoACE, intervaloConfiancaACE, erroPercentualACE),
AD = c(reg2p_nex$estimation$estimate, reg2p_nex$estimation$g_variance, sqrt(reg2p_nex$estimation$g_variance), cir2p, erroPercentualDA),
ADE = c(VTCCponderadaDAE_final, VarponderadaDAE_final, erroPadrao_ponderadoDAE, intervaloConfiancaDAE, erroPercentualDAE)
)
data <- data.frame(
Resultados = c("Estimativa VTCC", "Variância", "Desvio Padrão", "Intervalo de confiança (95%)", "Erro (%)", IA),
ACS = c(op_ACS$estimation$estimate, op_ACS$estimation$variance, sqrt(op_ACS$estimation$variance), ciop, erroPercentualACS, 0),
ACE = c(VTCCponderadaACE_final, VarponderadaACE_final, erroPadrao_ponderadoACE, intervaloConfiancaACE, erroPercentualACE, 0),
AD = c(reg2p_nex$estimation$estimate, reg2p_nex$estimation$g_variance, sqrt(reg2p_nex$estimation$g_variance), cir2p, erroPercentualDA, 0),
ADE = c(VTCCponderadaDAE_final, VarponderadaDAE_final, erroPadrao_ponderadoDAE, intervaloConfiancaDAE, erroPercentualDAE, 0)
)
# Crie a tabela como um gráfico usando ggtexttable
tabela = ggtexttable(data, theme = ttheme("mBlue"))
rodape <- ggtexttable(
data.frame(Erro_desejado = erro, "%"),
rows = NULL,
theme = ttheme("light", base_size = 10, padding = unit(c(1, 1), "mm"))
)
# Combinar a tabela e o rodapé
final_plot <- ggarrange(tabela, rodape, ncol = 1, heights = c(3, 0.3))
final_plot
IA = str_c("Int. Amostral para erro de ", as.character(erro), "%")
data <- data.frame(
Resultados = c("Estimativa VTCC", "Variância", "Desvio Padrão", "Intervalo de confiança (95%)", "Erro (%)", IA),
ACS = c(op_ACS$estimation$estimate, op_ACS$estimation$variance, sqrt(op_ACS$estimation$variance), ciop, erroPercentualACS, 0),
ACE = c(VTCCponderadaACE_final, VarponderadaACE_final, erroPadrao_ponderadoACE, intervaloConfiancaACE, erroPercentualACE, 0),
AD = c(reg2p_nex$estimation$estimate, reg2p_nex$estimation$g_variance, sqrt(reg2p_nex$estimation$g_variance), cir2p, erroPercentualDA, 0),
ADE = c(VTCCponderadaDAE_final, VarponderadaDAE_final, erroPadrao_ponderadoDAE, intervaloConfiancaDAE, erroPercentualDAE, 0)
)
# Crie a tabela como um gráfico usando ggtexttable
tabela = ggtexttable(data, theme = ttheme("mBlue"))
tabela
IA = str_c("Int. Amostral para erro de ", as.character(erro), "%")
data <- data.frame(
Resultados = c("Estimativa VTCC", "Variância", "Desvio Padrão", "Intervalo de confiança (95%)", "Erro (%)", IA),
ACS = c(op_ACS$estimation$estimate, op_ACS$estimation$variance, sqrt(op_ACS$estimation$variance), ciop, erroPercentualACS, tamanhoIdealACS),
ACE = c(VTCCponderadaACE_final, VarponderadaACE_final, erroPadrao_ponderadoACE, intervaloConfiancaACE, erroPercentualACE, tamanhoIdealACE),
AD = c(reg2p_nex$estimation$estimate, reg2p_nex$estimation$g_variance, sqrt(reg2p_nex$estimation$g_variance), cir2p, erroPercentualDA, 0),
ADE = c(VTCCponderadaDAE_final, VarponderadaDAE_final, erroPadrao_ponderadoDAE, intervaloConfiancaDAE, erroPercentualDAE, 0)
)
# Crie a tabela como um gráfico usando ggtexttable
tabela = ggtexttable(data, theme = ttheme("mBlue"))
tabela
IA = str_c("Número de parcelas por hectare para erro de ", as.character(erro), "%")
data <- data.frame(
Resultados = c("Estimativa VTCC", "Variância", "Desvio Padrão", "Intervalo de confiança (95%)", "Erro (%)", IA),
ACS = c(op_ACS$estimation$estimate, op_ACS$estimation$variance, sqrt(op_ACS$estimation$variance), ciop, erroPercentualACS, tamanhoIdealACS),
ACE = c(VTCCponderadaACE_final, VarponderadaACE_final, erroPadrao_ponderadoACE, intervaloConfiancaACE, erroPercentualACE, tamanhoIdealACE),
AD = c(reg2p_nex$estimation$estimate, reg2p_nex$estimation$g_variance, sqrt(reg2p_nex$estimation$g_variance), cir2p, erroPercentualDA, 0),
ADE = c(VTCCponderadaDAE_final, VarponderadaDAE_final, erroPadrao_ponderadoDAE, intervaloConfiancaDAE, erroPercentualDAE, 0)
)
# Crie a tabela como um gráfico usando ggtexttable
tabela = ggtexttable(data, theme = ttheme("mBlue"))
IA = str_c("Hectares/parcelas para atingir erro de ", as.character(erro), "%")
data <- data.frame(
Resultados = c("Estimativa VTCC", "Variância", "Desvio Padrão", "Intervalo de confiança (95%)", "Erro (%)", IA),
ACS = c(op_ACS$estimation$estimate, op_ACS$estimation$variance, sqrt(op_ACS$estimation$variance), ciop, erroPercentualACS, tamanhoIdealACS),
ACE = c(VTCCponderadaACE_final, VarponderadaACE_final, erroPadrao_ponderadoACE, intervaloConfiancaACE, erroPercentualACE, tamanhoIdealACE),
AD = c(reg2p_nex$estimation$estimate, reg2p_nex$estimation$g_variance, sqrt(reg2p_nex$estimation$g_variance), cir2p, erroPercentualDA, 0),
ADE = c(VTCCponderadaDAE_final, VarponderadaDAE_final, erroPadrao_ponderadoDAE, intervaloConfiancaDAE, erroPercentualDAE, 0)
)
# Crie a tabela como um gráfico usando ggtexttable
tabela = ggtexttable(data, theme = ttheme("mBlue"))
tabela
IA = str_c("ha/1 parc. para erro de ", as.character(erro), "%")
data <- data.frame(
Resultados = c("Estimativa VTCC", "Variância", "Desvio Padrão", "Intervalo de confiança (95%)", "Erro (%)", IA),
ACS = c(op_ACS$estimation$estimate, op_ACS$estimation$variance, sqrt(op_ACS$estimation$variance), ciop, erroPercentualACS, tamanhoIdealACS),
ACE = c(VTCCponderadaACE_final, VarponderadaACE_final, erroPadrao_ponderadoACE, intervaloConfiancaACE, erroPercentualACE, tamanhoIdealACE),
AD = c(reg2p_nex$estimation$estimate, reg2p_nex$estimation$g_variance, sqrt(reg2p_nex$estimation$g_variance), cir2p, erroPercentualDA, 0),
ADE = c(VTCCponderadaDAE_final, VarponderadaDAE_final, erroPadrao_ponderadoDAE, intervaloConfiancaDAE, erroPercentualDAE, 0)
)
# Crie a tabela como um gráfico usando ggtexttable
tabela = ggtexttable(data, theme = ttheme("mBlue"))
tabela
tamanhoIdealAC_fun = function(y, N, errDesired=erro/100, alpha=.05){ # Y vai receber o data.frame com a VTCC de cada parcela de campo e N vai receber o número máximo de parcelas de campo
B  =  errDesired * mean(y) # B representa o erro absoluto; é a média das VTCC * 0,1 -> é uma constante que representa o valor do erro de 10% em m³ por ha, se passar do valor de B, então o erro é maior do que 10%
qt = qt(1 - alpha/2, length(y)-1) # quantil 97,5% - 95% de confiança para o grau de liberdade delimitado (13 parcelas de campo - 1 = 12)
n  = N*var(y)*qt^2 / (N * B^2 + qt^2 * var(y)) # Calcula o tamanho ideal de amostra baseando-se na variância de y, no tamanho máx. da pop (N), no limite do erro B e na confiança desejada (95%)
return(n)
}
parcelaAreaMedia <- mean(final_df$AREAPARCEL) / 10000          # quantidade de parcelas de campo por ha com base na média de suas áreas
N_max <- round(areaTotal / parcelaAreaMedia , 0)
N_max_est = c()
foreach (i = 1:length(unique(X$IDINV))) %do% {
N_max_est[i] <- round((sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]]) / parcelaAreaMedia), 2)
}
### Intensidade Amostral: ACS - resultado em n° parc. por ha
tamanhoIdealACS = round(areaTotal/(tamanhoIdealAC(X$VTCC[X$Inventario == 2], N_max)), 2)
### Intensidade Amostral: ACS - resultado em n° parc. por ha
tamanhoIdealACS = round(areaTotal/(tamanhoIdealAC_fun(X$VTCC[X$Inventario == 2], N_max)), 2)
### Intensidade Amostral: ACE -                !!!!!!!depois fazer na mão!!!!!!!
tamanhoIdealACE_aux = c()
foreach (i = 0:length(unique(X$IDINV))) %do% {
tamanhoIdealACE_aux[i] = c(round(areaTotal/(tamanhoIdealACfun(X$VTCC[X$Inventario == 2 & X$IDINV == idadesEstratos[i]], N_max_est)), 2))
tamanhoIdealACE_aux[i] = tamanhoIdealACE_aux[i]*(sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]]))/(areaTotal)
}
foreach (i = 0:length(unique(X$IDINV))) %do% {
tamanhoIdealACE_aux[i] = c(round(areaTotal/(tamanhoIdealAC_fun(X$VTCC[X$Inventario == 2 & X$IDINV == idadesEstratos[i]], N_max_est)), 2))
tamanhoIdealACE_aux[i] = tamanhoIdealACE_aux[i]*(sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]]))/(areaTotal)
}
tamanhoIdealACE = sum(tamanhoIdealACE_aux)
tamanhoIdealACE
tamanhoIdealACE
IA = str_c("ha/1 parc. para erro de ", as.character(erro), "%")
data <- data.frame(
Resultados = c("Estimativa VTCC", "Variância", "Desvio Padrão", "Intervalo de confiança (95%)", "Erro (%)", IA),
ACS = c(op_ACS$estimation$estimate, op_ACS$estimation$variance, sqrt(op_ACS$estimation$variance), ciop, erroPercentualACS, tamanhoIdealACS),
ACE = c(VTCCponderadaACE_final, VarponderadaACE_final, erroPadrao_ponderadoACE, intervaloConfiancaACE, erroPercentualACE, tamanhoIdealACE),
AD = c(reg2p_nex$estimation$estimate, reg2p_nex$estimation$g_variance, sqrt(reg2p_nex$estimation$g_variance), cir2p, erroPercentualDA, 0),
ADE = c(VTCCponderadaDAE_final, VarponderadaDAE_final, erroPadrao_ponderadoDAE, intervaloConfiancaDAE, erroPercentualDAE, 0)
)
# Crie a tabela como um gráfico usando ggtexttable
tabela = ggtexttable(data, theme = ttheme("mBlue"))
tabela
sae.est <- twophase(formula = tvol ~ mean + stddev + max + q75,
data = grisons,
phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
small_area = list(sa.col = "smallarea",
areas = c("A", "B","C", "D"),
unbiased = TRUE))
confint(sae.est, adjust.method = "bonferroni")
var(X$VTCC[X$Inventario == 2 & X$IDINV == idadesEstratos[1]])
N_max_est = c()
foreach (i = 1:length(unique(X$IDINV))) %do% {
N_max_est[i] <- round((sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]]) / parcelaAreaMedia), 2)
}
var(X$VTCC[X$Inventario == 2 & X$IDINV == idadesEstratos[2]])
teste = (((1417.71*40.05)/sqrt(5))/(((1417*40.05)/sqrt(5))+((2027.85*41.7)/(sqrt(8)))))
teste
teste1 = teste*13
teste1
teste = (((1417.71*40.05)/sqrt(5))/(((1417*40.05)/sqrt(5))+((2027.85*41.7)/(sqrt(8)))))
teste1 = (((2027.85*41.7)/sqrt(5))/(((1417*40.05)/sqrt(5))+((2027.85*41.7)/(sqrt(8)))))
print(teste1)
print(teste)
var(X$VTCC[X$Inventario == 2 & X$IDINV == idadesEstratos[1]])
Vargraus = sqrt(var(X$VTCC[X$Inventario == 2 & X$IDINV == idadesEstratos[1]]))/4
Vargraus
X$VTCC[X$Inventario == 2 && X$IDINV == 3.7]
X$VTCC[X$Inventario == 2 & X$IDINV == 3.7]
Sy_aux = c(X$VTCC[X$Inventario == 2 & X$IDINV == 3.7])
Sy_aux
Sy_aux^2
Sy = sum(Sy_aux^2) - (sum(X$VTCC[X$Inventario == 2 & X$IDINV == 3.7])^2)/5
Sy
S2h = Sy/4
S2h
var(X$VTCC[X$Inventario == 2 & X$IDINV == 3.7]))
var(X$VTCC[X$Inventario == 2 & X$IDINV == 3.7])
tamanhoIdealACE_aux
### Intensidade Amostral: ACE -                !!!!!!!depois fazer na mão!!!!!!!
tamanhoIdealACE_aux = c()
N_max_est
var(X$VTCC[X$Inventario == 2 & X$IDINV == 3.7])
op_ACE$estimation$n2[1]
wh_aux = c()
teste = (((1417.71*40.05)/sqrt(5))/(((1417*40.05)/sqrt(5))+((2027.85*41.7)/(sqrt(8)))))
print(teste) # W para 3.7
teste1 = (((2027.85*41.7)/sqrt(5))/(((1417*40.05)/sqrt(5))+((2027.85*41.7)/(sqrt(8)))))
print(teste1)
teste = (((1417.71*40.05)/sqrt(5))/(((1417*40.05)/sqrt(5))+((2027.85*41.7)/(sqrt(8)))))
print(teste) # W para 3.7
teste1 = (((2027.85*41.7)/sqrt(8))/(((1417*40.05)/sqrt(5))+((2027.85*41.7)/(sqrt(8)))))
print(teste1)
S2h
idade_menor = ((N_max_est[1]^2)*var(X$VTCC[X$Inventario == 2 & X$IDINV == 3.7]))/teste
idade_menor
mean(X$VTCC[X$Inventario == 2 & X$IDINV == 3.7])
aux_menor_B = mean(X$VTCC[X$Inventario == 2 & X$IDINV == 3.7])*0.1
aux_menor_B
N_max
mean(X$VTCC)
X$VTCC
mean(X$VTCC[X$Inventario == 2])
aux_B_N_t = (mean(X$VTCC[X$Inventario == 2])*0.1*N_max^2)/(qt(1 - 0.05/2, 12))^2
aux_B_N_t
idade_menor = ((N_max_est[1]^2)*var(X$VTCC[X$Inventario == 2 & X$IDINV == 3.7]))/teste
idade_menor
soma_final_id_menor = N_max_est[1]*var(X$VTCC[X$Inventario == 2 & X$IDINV == 3.7])
soma_final_id_menor
idade_menor = ((N_max_est[1]^2)*var(X$VTCC[X$Inventario == 2 & X$IDINV == 3.7]))/teste
idade_maior = ((N_max_est[2]^2)*var(X$VTCC[X$Inventario == 2 & X$IDINV == 5.2]))/teste1
aux_B_N_t = (mean(X$VTCC[X$Inventario == 2])*0.1*N_max^2)/(qt(1 - 0.05/2, 12))^2
soma_final_id_menor = N_max_est[1]*var(X$VTCC[X$Inventario == 2 & X$IDINV == 3.7])
soma_final_id_maior = N_max_est[2]*var(X$VTCC[X$Inventario == 2 & X$IDINV == 5.2])
fim = idade_menor + idade_maior
fim1 = soma_final_id_maior + soma_final_id_menor
print(fim/(aux_B_N_t + fim1))
print(teste) # W para 3.7
print(teste1)
idade_menor = ((N_max_est[1]^2)*var(X$VTCC[X$Inventario == 2 & X$IDINV == 3.7]))/teste
idade_maior = ((N_max_est[2]^2)*var(X$VTCC[X$Inventario == 2 & X$IDINV == 5.2]))/teste1
fim = idade_menor + idade_maior
aux_B_N_t = (mean(X$VTCC[X$Inventario == 2])*0.1*N_max^2)/(qt(1 - 0.05/2, 12))^2
soma_final_id_menor = N_max_est[1]*var(X$VTCC[X$Inventario == 2 & X$IDINV == 3.7])
soma_final_id_maior = N_max_est[2]*var(X$VTCC[X$Inventario == 2 & X$IDINV == 5.2])
fim1 = soma_final_id_maior + soma_final_id_menor
print(fim/(aux_B_N_t + fim1))
idade_menor
idade_maior
fim
aux_B_N_t
soma_final_id_menor
soma_final_id_maior
IA = str_c("ha/1 parc. para erro de ", as.character(erro), "%")
data <- data.frame(
Resultados = c("Estimativa VTCC", "Variância", "Desvio Padrão", "Intervalo de confiança (95%)", "Erro (%)", IA),
ACS = c(op_ACS$estimation$estimate, op_ACS$estimation$variance, sqrt(op_ACS$estimation$variance), ciop, erroPercentualACS, tamanhoIdealACS),
ACE = c(VTCCponderadaACE_final, VarponderadaACE_final, erroPadrao_ponderadoACE, intervaloConfiancaACE, erroPercentualACE, tamanhoIdealACE),
AD = c(reg2p_nex$estimation$estimate, reg2p_nex$estimation$g_variance, sqrt(reg2p_nex$estimation$g_variance), cir2p, erroPercentualDA, 0),
ADE = c(VTCCponderadaDAE_final, VarponderadaDAE_final, erroPadrao_ponderadoDAE, intervaloConfiancaDAE, erroPercentualDAE, 0)
)
# Crie a tabela como um gráfico usando ggtexttable
tabela = ggtexttable(data, theme = ttheme("mBlue"))
tabela
data <- data.frame(
Resultados = c("Estimativa VTCC", "Variância", "Desvio Padrão", "Intervalo de confiança (95%)", "Erro (%)"),
ACS = c(op_ACS$estimation$estimate, op_ACS$estimation$variance, sqrt(op_ACS$estimation$variance), ciop, erroPercentualACS),
ACE = c(VTCCponderadaACE_final, VarponderadaACE_final, erroPadrao_ponderadoACE, intervaloConfiancaACE, erroPercentualACE),
AD = c(reg2p_nex$estimation$estimate, reg2p_nex$estimation$g_variance, sqrt(reg2p_nex$estimation$g_variance), cir2p, erroPercentualDA),
ADE = c(VTCCponderadaDAE_final, VarponderadaDAE_final, erroPadrao_ponderadoDAE, intervaloConfiancaDAE, erroPercentualDAE)
)
# Crie a tabela como um gráfico usando ggtexttable
tabela = ggtexttable(data, theme = ttheme("mBlue"))
tabela
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Cálculo do número ideal de unidades amostrais em double sampling, ou
# seja, da intensidade amostral necessária para gerar o erro admissível
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dsNumberOfPlots = function(y, x, xLarge, Cpg = 300,
errDesired = .05, alpha = .05){
rho = cor(x,y)
a = var(y) * (1 - rho^2)
b = var(y) * rho^2
B = errDesired * mean(y)
qt = qt(1 - alpha/2, length(y)-1)
nG = (sqrt( a*b*Cpg ) + b) / (B^2 / qt^2)
nP = (sqrt( a*b/Cpg ) + a) / (B^2 / qt^2)
return(nP)
}
seramesmo = dsNumberOfPlots(y = reg2p_nex$estimation$estimate,
x = X$zq95)
seramesmo = dsNumberOfPlots(y = X$VTCC,
x = X$zq95[X$Inventario == 2])
e
seramesmo = dsNumberOfPlots(y = X$VTCC[X$Inventario == 2],
x = X$zq95[X$Inventario == 2])
seramesmo
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Cálculo do número ideal de unidades amostrais em double sampling, ou
# seja, da intensidade amostral necessária para gerar o erro admissível
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dsNumberOfPlots = function(y, x, xLarge, Cpg = 300,
errDesired = .1, alpha = .05){
rho = cor(x,y)
a = var(y) * (1 - rho^2)
b = var(y) * rho^2
B = errDesired * mean(y)
qt = qt(1 - alpha/2, length(y)-1)
nG = (sqrt( a*b*Cpg ) + b) / (B^2 / qt^2)
nP = (sqrt( a*b/Cpg ) + a) / (B^2 / qt^2)
return(nP)
}
seramesmo = dsNumberOfPlots(y = X$VTCC[X$Inventario == 2],
x = X$zq95[X$Inventario == 2])
seramesmo
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Cálculo do número ideal de unidades amostrais em double sampling, ou
# seja, da intensidade amostral necessária para gerar o erro admissível
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dsNumberOfPlots = function(y, x, xLarge, Cpg = 300,
errDesired = 0.1, alpha = 0.05){
rho = cor(x,y)
a = var(y) * (1 - rho^2)
b = var(y) * rho^2
B = errDesired * mean(y)
qt = qt(1 - alpha/2, length(y)-1)
nG = (sqrt( a*b*Cpg ) + b) / (B^2 / qt^2)
nP = (sqrt( a*b/Cpg ) + a) / (B^2 / qt^2)
return(nP)
}
seramesmo = dsNumberOfPlots(y = X$VTCC[X$Inventario == 2],
x = X$zq95[X$Inventario == 2])
seramesmo
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Cálculo do número ideal de unidades amostrais em double sampling, ou
# seja, da intensidade amostral necessária para gerar o erro admissível
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dsNumberOfPlots = function(y, x, xLarge, Cpg = 300,
errDesired = 0.1, alpha = 0.05){
rho = cor(x,y)
a = var(y) * (1 - rho^2)
b = var(y) * rho^2
B = errDesired * mean(y)
qt = qt(1 - alpha/2, length(y)-1)
nG = (sqrt( a*b*Cpg ) + b) / (B^2 / qt^2)
nP = (sqrt( a*b/Cpg ) + a) / (B^2 / qt^2)
return(rho)
}
dsNumberOfPlots
seramesmo = dsNumberOfPlots(y = X$VTCC[X$Inventario == 2],
x = X$zq95[X$Inventario == 2])
seramesmo
X
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Cálculo do número ideal de unidades amostrais em double sampling, ou
# seja, da intensidade amostral necessária para gerar o erro admissível
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dsNumberOfPlots = function(y, x, xLarge, Cpg = 300,
errDesired = 0.1, alpha = 0.05){
rho = cor(x,y)
a = var(y) * (1 - rho^2)
b = var(y) * rho^2
B = errDesired * mean(y)
qt = qt(1 - alpha/2, length(y)-1)
nG = (sqrt( a*b*Cpg ) + b) / (B^2 / qt^2)
nP = (sqrt( a*b/Cpg ) + a) / (B^2 / qt^2)
return(nP)
}
seramesmo = dsNumberOfPlots(y = X$zq95[X$Inventario == 2],
x = X$VTCC[X$Inventario == 2])
seramesmo
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Cálculo do número ideal de unidades amostrais em double sampling, ou
# seja, da intensidade amostral necessária para gerar o erro admissível
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dsNumberOfPlots = function(y, x, xLarge, Cpg = 300,
errDesired = 0.1, alpha = 0.05){
rho = cor(x,y)
a = var(y) * (1 - rho^2)
b = var(y) * rho^2
B = errDesired * mean(y)
qt = qt(1 - alpha/2, length(y)-1)
nG = (sqrt( a*b*Cpg ) + b) / (B^2 / qt^2)
nP = (sqrt( a*b/Cpg ) + a) / (B^2 / qt^2)
return(rho)
}
seramesmo = dsNumberOfPlots(y = X$zq95[X$Inventario == 2],
x = X$VTCC[X$Inventario == 2])
seramesmo
seramesmo = dsNumberOfPlots(x = X$zq95[X$Inventario == 2],
y = X$VTCC[X$Inventario == 2])
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Cálculo do número ideal de unidades amostrais em double sampling, ou
# seja, da intensidade amostral necessária para gerar o erro admissível
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dsNumberOfPlots = function(y, x, xLarge, Cpg = 300,
errDesired = 0.1, alpha = 0.05){
rho = cor(x,y)
a = var(y) * (1 - rho^2)
b = var(y) * rho^2
B = errDesired * mean(y)
qt = qt(1 - alpha/2, length(y)-1)
nG = (sqrt( a*b*Cpg ) + b) / (B^2 / qt^2)
nP = (sqrt( a*b/Cpg ) + a) / (B^2 / qt^2)
return(rho)
}
seramesmo
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Cálculo do número ideal de unidades amostrais em double sampling, ou
# seja, da intensidade amostral necessária para gerar o erro admissível
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dsNumberOfPlots = function(y, x, xLarge, Cpg = 300,
errDesired = 0.1, alpha = 0.05){
rho = cor(x,y)
a = var(y) * (1 - rho^2)
b = var(y) * rho^2
B = errDesired * mean(y)
qt = qt(1 - alpha/2, length(y)-1)
nG = (sqrt( a*b*Cpg ) + b) / (B^2 / qt^2)
nP = (sqrt( a*b/Cpg ) + a) / (B^2 / qt^2)
return(nP)
}
seramesmo = dsNumberOfPlots(x = X$zq95[X$Inventario == 2],
y = X$VTCC[X$Inventario == 2])
seramesmo
seramesmo = dsNumberOfPlots(x = X$zq95,
y = X$VTCC)
seramesmo
summary(op_ACS) # Printa as estimativas
confint(op_ACS) # Printa a estimativa da variável de interesse
intervaloConfiancaACE
erroPercentualACE
erroPercentualDA
reg2p_nex_est$estimation$n2
load("C:/GitRepo/PRJ_FAZENDAMODELO/BATCHR/DA-forestinventory-finalizada.RData")
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----
if(!require(tidyverse))    # Para melhor manipulação de dados e funções
install.packages("tidyverse")
library(tidyverse)
if(!require(ggplot2))
install.packages("ggplot2")
library(ggplot2)
if(!require(ggpubr))
install.packages("ggpubr")
library(ggpubr)
if(!require(sf))            # Para manipulação de shapes e outros tipos
install.packages("sf")                      # de dados espacializados
library(sf)
if(!require(foreach))
install.packages("foreach")
library(foreach)
if(!require(tidyterra))           # Package para processar mapas raster
install.packages("tidyterra")
library(tidyterra)
if(!require(terra))           # Package para processar mapas raster
install.packages("terra")
library(terra)
if(!require(stars))                  # Package que permite rasterização
install.packages("stars")
library(stars)
if(!require(tools))           # Package para manipular nomes de aquivos
install.packages("tools")
library(tools)
if(!require(RColorBrewer))          # Package com mais paletas de cores
install.packages("RColorBrewer")
library(RColorBrewer)
if(!require(progress))          # Package com mais paletas de cores
install.packages("progress")
library(progress)
if(!require(reshape2))              # Usado na função que gera gráficos
install.packages("reshape2")         # mais caprichados de correlação
library(reshape2)
if(!require(mapview))             # Package para incluir mapas de fundo
install.packages("mapview")
library(mapview)
if(!require(forestinventory))             # Package para incluir mapas de fundo
install.packages("forestinventory")
library(forestinventory)
# devtools::install_github("Jean-Romain/rlas", dependencies=TRUE)
# devtools::install_github("Jean-Romain/lidR")
if(!require(lidR))                     # PARA MANPULAÇÃO DE DADOS LiDAR
install.packages("lidR") # Se preferir instalar a versão mais recente
library(lidR)              # e tiver o package devtools instalado, rode
# alternativamente as duas linhas acima
if(!require(RCSF))    #        Pacote complementar do lidR e necessário
install.packages("RCSF")           # rodar a função classify_ground()
library(RCSF)
if(!require(future))         # Package que permite ao lidR rodar usando
install.packages("future")          # processamento paralelo de dados
library(future)
